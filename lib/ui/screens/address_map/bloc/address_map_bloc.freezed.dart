// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'address_map_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AddressMapEventTearOff {
  const _$AddressMapEventTearOff();

  _SaveAddress saveAddress(
      {required String locality,
      required String house,
      required String nickName,
      required String pincode,
      required double lat,
      required double lng}) {
    return _SaveAddress(
      locality: locality,
      house: house,
      nickName: nickName,
      pincode: pincode,
      lat: lat,
      lng: lng,
    );
  }

  _UseAddress useAddress(
      {required String locality,
      required String house,
      required String nickName,
      required String pincode,
      required double lat,
      required double lng}) {
    return _UseAddress(
      locality: locality,
      house: house,
      nickName: nickName,
      pincode: pincode,
      lat: lat,
      lng: lng,
    );
  }
}

/// @nodoc
const $AddressMapEvent = _$AddressMapEventTearOff();

/// @nodoc
mixin _$AddressMapEvent {
  String get locality => throw _privateConstructorUsedError;
  String get house => throw _privateConstructorUsedError;
  String get nickName => throw _privateConstructorUsedError;
  String get pincode => throw _privateConstructorUsedError;
  double get lat => throw _privateConstructorUsedError;
  double get lng => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        saveAddress,
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        useAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        saveAddress,
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        useAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SaveAddress value) saveAddress,
    required TResult Function(_UseAddress value) useAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SaveAddress value)? saveAddress,
    TResult Function(_UseAddress value)? useAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddressMapEventCopyWith<AddressMapEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressMapEventCopyWith<$Res> {
  factory $AddressMapEventCopyWith(
          AddressMapEvent value, $Res Function(AddressMapEvent) then) =
      _$AddressMapEventCopyWithImpl<$Res>;
  $Res call(
      {String locality,
      String house,
      String nickName,
      String pincode,
      double lat,
      double lng});
}

/// @nodoc
class _$AddressMapEventCopyWithImpl<$Res>
    implements $AddressMapEventCopyWith<$Res> {
  _$AddressMapEventCopyWithImpl(this._value, this._then);

  final AddressMapEvent _value;
  // ignore: unused_field
  final $Res Function(AddressMapEvent) _then;

  @override
  $Res call({
    Object? locality = freezed,
    Object? house = freezed,
    Object? nickName = freezed,
    Object? pincode = freezed,
    Object? lat = freezed,
    Object? lng = freezed,
  }) {
    return _then(_value.copyWith(
      locality: locality == freezed
          ? _value.locality
          : locality // ignore: cast_nullable_to_non_nullable
              as String,
      house: house == freezed
          ? _value.house
          : house // ignore: cast_nullable_to_non_nullable
              as String,
      nickName: nickName == freezed
          ? _value.nickName
          : nickName // ignore: cast_nullable_to_non_nullable
              as String,
      pincode: pincode == freezed
          ? _value.pincode
          : pincode // ignore: cast_nullable_to_non_nullable
              as String,
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as double,
      lng: lng == freezed
          ? _value.lng
          : lng // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$SaveAddressCopyWith<$Res>
    implements $AddressMapEventCopyWith<$Res> {
  factory _$SaveAddressCopyWith(
          _SaveAddress value, $Res Function(_SaveAddress) then) =
      __$SaveAddressCopyWithImpl<$Res>;
  @override
  $Res call(
      {String locality,
      String house,
      String nickName,
      String pincode,
      double lat,
      double lng});
}

/// @nodoc
class __$SaveAddressCopyWithImpl<$Res>
    extends _$AddressMapEventCopyWithImpl<$Res>
    implements _$SaveAddressCopyWith<$Res> {
  __$SaveAddressCopyWithImpl(
      _SaveAddress _value, $Res Function(_SaveAddress) _then)
      : super(_value, (v) => _then(v as _SaveAddress));

  @override
  _SaveAddress get _value => super._value as _SaveAddress;

  @override
  $Res call({
    Object? locality = freezed,
    Object? house = freezed,
    Object? nickName = freezed,
    Object? pincode = freezed,
    Object? lat = freezed,
    Object? lng = freezed,
  }) {
    return _then(_SaveAddress(
      locality: locality == freezed
          ? _value.locality
          : locality // ignore: cast_nullable_to_non_nullable
              as String,
      house: house == freezed
          ? _value.house
          : house // ignore: cast_nullable_to_non_nullable
              as String,
      nickName: nickName == freezed
          ? _value.nickName
          : nickName // ignore: cast_nullable_to_non_nullable
              as String,
      pincode: pincode == freezed
          ? _value.pincode
          : pincode // ignore: cast_nullable_to_non_nullable
              as String,
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as double,
      lng: lng == freezed
          ? _value.lng
          : lng // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_SaveAddress implements _SaveAddress {
  const _$_SaveAddress(
      {required this.locality,
      required this.house,
      required this.nickName,
      required this.pincode,
      required this.lat,
      required this.lng});

  @override
  final String locality;
  @override
  final String house;
  @override
  final String nickName;
  @override
  final String pincode;
  @override
  final double lat;
  @override
  final double lng;

  @override
  String toString() {
    return 'AddressMapEvent.saveAddress(locality: $locality, house: $house, nickName: $nickName, pincode: $pincode, lat: $lat, lng: $lng)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SaveAddress &&
            (identical(other.locality, locality) ||
                const DeepCollectionEquality()
                    .equals(other.locality, locality)) &&
            (identical(other.house, house) ||
                const DeepCollectionEquality().equals(other.house, house)) &&
            (identical(other.nickName, nickName) ||
                const DeepCollectionEquality()
                    .equals(other.nickName, nickName)) &&
            (identical(other.pincode, pincode) ||
                const DeepCollectionEquality()
                    .equals(other.pincode, pincode)) &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lng, lng) ||
                const DeepCollectionEquality().equals(other.lng, lng)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(locality) ^
      const DeepCollectionEquality().hash(house) ^
      const DeepCollectionEquality().hash(nickName) ^
      const DeepCollectionEquality().hash(pincode) ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lng);

  @JsonKey(ignore: true)
  @override
  _$SaveAddressCopyWith<_SaveAddress> get copyWith =>
      __$SaveAddressCopyWithImpl<_SaveAddress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        saveAddress,
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        useAddress,
  }) {
    return saveAddress(locality, house, nickName, pincode, lat, lng);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        saveAddress,
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        useAddress,
    required TResult orElse(),
  }) {
    if (saveAddress != null) {
      return saveAddress(locality, house, nickName, pincode, lat, lng);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SaveAddress value) saveAddress,
    required TResult Function(_UseAddress value) useAddress,
  }) {
    return saveAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SaveAddress value)? saveAddress,
    TResult Function(_UseAddress value)? useAddress,
    required TResult orElse(),
  }) {
    if (saveAddress != null) {
      return saveAddress(this);
    }
    return orElse();
  }
}

abstract class _SaveAddress implements AddressMapEvent {
  const factory _SaveAddress(
      {required String locality,
      required String house,
      required String nickName,
      required String pincode,
      required double lat,
      required double lng}) = _$_SaveAddress;

  @override
  String get locality => throw _privateConstructorUsedError;
  @override
  String get house => throw _privateConstructorUsedError;
  @override
  String get nickName => throw _privateConstructorUsedError;
  @override
  String get pincode => throw _privateConstructorUsedError;
  @override
  double get lat => throw _privateConstructorUsedError;
  @override
  double get lng => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SaveAddressCopyWith<_SaveAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UseAddressCopyWith<$Res>
    implements $AddressMapEventCopyWith<$Res> {
  factory _$UseAddressCopyWith(
          _UseAddress value, $Res Function(_UseAddress) then) =
      __$UseAddressCopyWithImpl<$Res>;
  @override
  $Res call(
      {String locality,
      String house,
      String nickName,
      String pincode,
      double lat,
      double lng});
}

/// @nodoc
class __$UseAddressCopyWithImpl<$Res>
    extends _$AddressMapEventCopyWithImpl<$Res>
    implements _$UseAddressCopyWith<$Res> {
  __$UseAddressCopyWithImpl(
      _UseAddress _value, $Res Function(_UseAddress) _then)
      : super(_value, (v) => _then(v as _UseAddress));

  @override
  _UseAddress get _value => super._value as _UseAddress;

  @override
  $Res call({
    Object? locality = freezed,
    Object? house = freezed,
    Object? nickName = freezed,
    Object? pincode = freezed,
    Object? lat = freezed,
    Object? lng = freezed,
  }) {
    return _then(_UseAddress(
      locality: locality == freezed
          ? _value.locality
          : locality // ignore: cast_nullable_to_non_nullable
              as String,
      house: house == freezed
          ? _value.house
          : house // ignore: cast_nullable_to_non_nullable
              as String,
      nickName: nickName == freezed
          ? _value.nickName
          : nickName // ignore: cast_nullable_to_non_nullable
              as String,
      pincode: pincode == freezed
          ? _value.pincode
          : pincode // ignore: cast_nullable_to_non_nullable
              as String,
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as double,
      lng: lng == freezed
          ? _value.lng
          : lng // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UseAddress implements _UseAddress {
  const _$_UseAddress(
      {required this.locality,
      required this.house,
      required this.nickName,
      required this.pincode,
      required this.lat,
      required this.lng});

  @override
  final String locality;
  @override
  final String house;
  @override
  final String nickName;
  @override
  final String pincode;
  @override
  final double lat;
  @override
  final double lng;

  @override
  String toString() {
    return 'AddressMapEvent.useAddress(locality: $locality, house: $house, nickName: $nickName, pincode: $pincode, lat: $lat, lng: $lng)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UseAddress &&
            (identical(other.locality, locality) ||
                const DeepCollectionEquality()
                    .equals(other.locality, locality)) &&
            (identical(other.house, house) ||
                const DeepCollectionEquality().equals(other.house, house)) &&
            (identical(other.nickName, nickName) ||
                const DeepCollectionEquality()
                    .equals(other.nickName, nickName)) &&
            (identical(other.pincode, pincode) ||
                const DeepCollectionEquality()
                    .equals(other.pincode, pincode)) &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lng, lng) ||
                const DeepCollectionEquality().equals(other.lng, lng)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(locality) ^
      const DeepCollectionEquality().hash(house) ^
      const DeepCollectionEquality().hash(nickName) ^
      const DeepCollectionEquality().hash(pincode) ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lng);

  @JsonKey(ignore: true)
  @override
  _$UseAddressCopyWith<_UseAddress> get copyWith =>
      __$UseAddressCopyWithImpl<_UseAddress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        saveAddress,
    required TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)
        useAddress,
  }) {
    return useAddress(locality, house, nickName, pincode, lat, lng);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        saveAddress,
    TResult Function(String locality, String house, String nickName,
            String pincode, double lat, double lng)?
        useAddress,
    required TResult orElse(),
  }) {
    if (useAddress != null) {
      return useAddress(locality, house, nickName, pincode, lat, lng);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SaveAddress value) saveAddress,
    required TResult Function(_UseAddress value) useAddress,
  }) {
    return useAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SaveAddress value)? saveAddress,
    TResult Function(_UseAddress value)? useAddress,
    required TResult orElse(),
  }) {
    if (useAddress != null) {
      return useAddress(this);
    }
    return orElse();
  }
}

abstract class _UseAddress implements AddressMapEvent {
  const factory _UseAddress(
      {required String locality,
      required String house,
      required String nickName,
      required String pincode,
      required double lat,
      required double lng}) = _$_UseAddress;

  @override
  String get locality => throw _privateConstructorUsedError;
  @override
  String get house => throw _privateConstructorUsedError;
  @override
  String get nickName => throw _privateConstructorUsedError;
  @override
  String get pincode => throw _privateConstructorUsedError;
  @override
  double get lat => throw _privateConstructorUsedError;
  @override
  double get lng => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$UseAddressCopyWith<_UseAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddressMapStateTearOff {
  const _$AddressMapStateTearOff();

  _Loading loading() {
    return const _Loading();
  }

  _Loaded loaded() {
    return const _Loaded();
  }
}

/// @nodoc
const $AddressMapState = _$AddressMapStateTearOff();

/// @nodoc
mixin _$AddressMapState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressMapStateCopyWith<$Res> {
  factory $AddressMapStateCopyWith(
          AddressMapState value, $Res Function(AddressMapState) then) =
      _$AddressMapStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddressMapStateCopyWithImpl<$Res>
    implements $AddressMapStateCopyWith<$Res> {
  _$AddressMapStateCopyWithImpl(this._value, this._then);

  final AddressMapState _value;
  // ignore: unused_field
  final $Res Function(AddressMapState) _then;
}

/// @nodoc
abstract class _$LoadingCopyWith<$Res> {
  factory _$LoadingCopyWith(_Loading value, $Res Function(_Loading) then) =
      __$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadingCopyWithImpl<$Res> extends _$AddressMapStateCopyWithImpl<$Res>
    implements _$LoadingCopyWith<$Res> {
  __$LoadingCopyWithImpl(_Loading _value, $Res Function(_Loading) _then)
      : super(_value, (v) => _then(v as _Loading));

  @override
  _Loading get _value => super._value as _Loading;
}

/// @nodoc

class _$_Loading implements _Loading {
  const _$_Loading();

  @override
  String toString() {
    return 'AddressMapState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements AddressMapState {
  const factory _Loading() = _$_Loading;
}

/// @nodoc
abstract class _$LoadedCopyWith<$Res> {
  factory _$LoadedCopyWith(_Loaded value, $Res Function(_Loaded) then) =
      __$LoadedCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadedCopyWithImpl<$Res> extends _$AddressMapStateCopyWithImpl<$Res>
    implements _$LoadedCopyWith<$Res> {
  __$LoadedCopyWithImpl(_Loaded _value, $Res Function(_Loaded) _then)
      : super(_value, (v) => _then(v as _Loaded));

  @override
  _Loaded get _value => super._value as _Loaded;
}

/// @nodoc

class _$_Loaded implements _Loaded {
  const _$_Loaded();

  @override
  String toString() {
    return 'AddressMapState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Loaded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loaded,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements AddressMapState {
  const factory _Loaded() = _$_Loaded;
}
